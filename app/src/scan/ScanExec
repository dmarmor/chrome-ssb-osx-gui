#!/bin/bash
#
#  ScanExec: Main executable for Epichrome Scan.app
#
#  Copyright (C) 2020  David Marmor
#
#  https://github.com/dmarmor/epichrome
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#


# SCAN OR LOGIN APP SETUP

scanMode='EPISCANMODE'

if [[ "$scanMode" = 'login' ]] ; then
    myLogID='EpichromeLogin'
    myLogFilePrefix='epichrome_login_log'
fi


# CORE APP VARIABLES

myAppPath="${BASH_SOURCE[0]%/Contents/Resources/script}"
myScriptPath="$myAppPath/Contents/Resources/Scripts"

logNoStderr=1


# LOAD CORE SCRIPT

source "$myScriptPath/core.sh" 'coreDoInit=1' 'coreContext=scan' || exit 1
[[ "$ok" ]] || abort


# DON'T TRAP SIGINT

trap '' INT


# --- FUNCTION DEFINITIONS ---

# CLEANUP -- clean up from an interrupted scan
function cleanup {
    
    # we were interrupted in the middle of a restore
    if [[ "$restoreLock" && ( ! -f "$SSBAppPath/Contents/MacOS/Epichrome" ) ]] ; then
        errlog "Interrupted while restoring app $curApp. Attempting to complete restore."
        scan_restore CLEANUP
    fi
    
    # if nothing happened, quit parent app too
    # if [[ ! "$finalStatus" ]] ; then
    #     kill "$PPID"
    # fi
}


# SCAN_RESTORE: attempt to restore an app
#  scan_restore([CLEANUP]) -- if CLEANUP is set, we are running in the cleanup function
#    returns 0 on success, 1 on failure
restoreLock=
function scan_restore {
    
    local curAppErrID="Error restoring app $curApp"
    local iPrevErrs=()

    # turn on restore lock
    restoreLock=1
    
    if [[ -d "$myPayloadLauncherPath" ]] ; then
        
        if issamedevice "$myPayloadLauncherPath" "$SSBAppPath" ; then
            
            # launcher is in payload, so try the canonical method
            setenginestate OFF "$curApp"
            
            if [[ "$ok" ]] ; then
                restoreLock=
            else
                
                # save error message & restore state
                iPrevErrs+=( "${errmsg#${curAppErrID}: }" )
                ok=1 ; errmsg=

                # setenginestate failed, so try restoring launcher by hand
                debuglog "  App $curApp: Attempting to restore manually."
                
                try /bin/rm -rf "$SSBAppPath/Contents" \
                        "${curAppErrID}: Unable to remove engine contents manually."
                if [[ "$ok" ]] ; then
                    try /bin/mv "$myPayloadLauncherPath" "$SSBAppPath/Contents" \
                            "${curAppErrID}: Unable to restore launcher manually."
                fi
                
                if [[ "$ok" ]] ; then
                    restoreLock=
                    deletepayload '' "$curApp"
                fi
            fi
        else
            
            # payload is on wrong device
            ok= ; errmsg="${curAppErrID}: Payload is on a different device from app."
            errlog "$errmsg"
        fi
    else
        ok= ; errmsg="${curAppErrID}: Launcher not found in payload."
        errlog "$errmsg"
    fi
    
    if [[ "$restoreLock" ]] ; then
        
        # fallback: try to restore from failsafe backup
        debuglog "  App $curApp: Attempting to restore from failsafe backup."
        
        # save any earlier error
        if [[ ! "$ok" ]] ; then
            iPrevErrs+=( "${errmsg#${curAppErrID}: }" )
            ok=1 ; errmsg=
        fi
        
        # path to failsafe backup
        myFailsafeFile="$curApp/$appDataBackupDir/$appDataFailsafeFile"

        # try to restore from failsafe backup
        if [[ -f "$myFailsafeFile" ]] ; then
            try /bin/rm -rf "$SSBAppPath/Contents" \
                    "${curAppErrID}: Unable to remove engine contents."
            try /usr/bin/tar xzf "$myFailsafeFile" --cd "$SSBAppPath" \
                    "${curAppErrID}: Unable to restore from failsafe backup."
            [[ "$ok" ]] && restoreLock=
            deletepayload '' "$curApp"
        else
            ok=
            errmsg="${curAppErrID}: No failsafe backup found."
            errlog "$errmsg"
        fi
        
        if [[ ! "$ok" ]] ; then
            # format final error message for progress output
            iPrevErrs+=( "${errmsg#${curAppErrID}: }" )
            errmsg="$(join_array ' ' "${iPrevErrs[@]}")"
        fi
    fi
    
    # handle result
    local iResult=0
    if [[ "$restoreLock" ]] ; then
        iResult=1
        restoreLock=
    fi
    
    return "$iResult"
}


# PROGRESSMSG -- print a message for the progress bar
#  progressmsg(aDetail aAction aCurItem [aNumItems] [aStatusItem aStatusNum]...)
progressPrevStatus=
progressPrevTime=
function progressmsg {
    
    # arguments
    local aDetail="$1" ; shift ; [[ "$aDetail" ]] && aDetail+=$'\n'
    local aAction="$1" ; shift
    local aCurItem="$1" ; shift
    local aNumItems="$1" ; shift
    
    # build percentage (or count)
    local aPercent= aPercentNum=
    if [[ "$aCurItem" && "$aNumItems" ]] ; then
        aPercentNum="$(($aCurItem * 100 / $aNumItems))"
        aPercent=" ($aPercentNum%)"
    elif [[ "$aCurItem" || "$aNumItems" ]] ; then
        aPercent=" (${aCurItem}${aNumItems})"
    fi
    
    # build status text
    local aStatus= aCurStatus=
    while [[ "$#" -gt 0 ]] ; do
        [[ "$1" ]] && aCurStatus="$1"
        shift
        if [[ "$aCurStatus" ]] ; then
            if [[ "$1" ]] ; then
                # if this status has zero entries, skip it
                if [[ "$1" -eq 0 ]] ; then
                    shift
                    continue
                fi
                
                aCurStatus+=": $1"
            fi
            
            # add to status message
            [[ "$aStatus" ]] && aStatus+=', '
            aStatus+="$aCurStatus"
        fi
        shift
    done
    [[ "$aStatus" ]] && aStatus=" - $aStatus"
    
    # update time
    local iCurTime=
    try 'iCurTime=' /usr/bin/perl -MTime::HiRes=time -e 'printf "%.1f\n", time' ''
    ok=1 ; errmsg=
    iCurTime="${iCurTime/./}"
    
    # decide whether to show this message (every 0.3 sec, or if status changes)
    if [[ ( ( "$iCurTime" != "$progressPrevTime" ) && \
            ( "${iCurTime:$((${#iCurTime}-1)):1}" = [036] ) ) || \
            ( "$aStatus" != "$progressPrevStatus" ) ]] ; then
        echo "$aDetail$aAction$aPercent$aStatus"
    fi
    
    # save status for next run
    progressPrevStatus="$aStatus"
    progressPrevTime="$iCurTime"
}


# --- MAIN BODY ---

# initialize log file
initlogfile


# LOAD LAUNCH FUNCTIONS

safesource "$myScriptPath/launch.sh"
[[ "$ok" ]] || abort


# SCAN FOR ZOMBIE ENGINES

# navigate to Epichrome app data directory
try cd "$appDataPathBase" 'Unable to navigate to app data directory.'

# get list of everything in the directory
appDataDirItemList=( * )

# lists built during scan
appIDList=()
appRestoreSuccessList=()
appRestoreErrorList=()

# final status message
finalStatus=

# progress bar data
numItems="${#appDataDirItemList[@]}"
curItemNum=-1

for curApp in "${appDataDirItemList[@]}" ; do
    
    # reset ok status
    ok=1 ; errmsg=
    
    # clear config variables
    SSBPayloadPath=
    SSBAppPath=
    
    # update progress bar
    curItemNum=$(($curItemNum + 1))
    progressmsg "$curDetail" 'Scanning apps...' $curItemNum $numItems \
            'Restored' "${#appRestoreSuccessList[@]}" 'Failed' "${#appRestoreErrorList[@]}"
    
    # check if it's really an app directory
    [[ -d "$curApp" ]] || continue
    
    # add to (currently useless) list of IDs
    appIDList+=( "$curApp" )
    
    # check app's config file
    curConfig="$curApp/config.sh"
    if [[ ! -f "$curConfig" ]] ; then
        debuglog "Skipping app $curApp: no config file."
        continue
    fi
    
    # load config
    safesource "$curApp/config.sh" "config for app $curApp"
    [[ "$ok" ]] || continue
    
    # check payload directory
    if [[ ! "$SSBPayloadPath" ]] ; then
        debuglog "Skipping app $curApp: no payload path in config."
        continue
    fi
    
    # we have a current app to check
    debuglog "Checking app ID $curApp..."
    
    # find app
    if [[ ! "$SSBAppPath" || (! -d "$SSBAppPath" ) ]] ; then
        debuglog "  Current path for app $curApp not found in config. Finding by ID."
        
        try 'SSBAppPath=(n)' /usr/bin/osascript "$myScriptPath/launch.scpt" \
"{
   \"action\": \"find\",
   \"id\": \"$appIDBase.$curApp\"
}" \
                "Error finding app $curApp by ID."
        [[ "$ok" ]] || continue
            
        # make sure we found exactly one path
        if [[ "${#SSBAppPath[@]}" -lt 1 ]] ; then
            
            # no path found
            debuglog "  App $curApp not found."
            
            # remove orphan payload if it exists
            deletepayload '' "$curApp"
            continue
            
        elif [[ "${#SSBAppPath[@]}" -gt 1 ]] ; then
            
            # multiple apps found for this ID
            errlog "Cannot process app $curApp. ${#SSBAppPath[@]} different copies found:"
            for p in "${SSBAppPath[@]}" ; do errlog "  $p" ; done
            continue
        fi
        
        # set app path
        SSBAppPath="${SSBAppPath[0]}"
    fi
    
    # clear progress detail message
    curDetail=
    
    # make sure this app is not running
    if ! /usr/bin/pgrep -fiq -- "--epichrome-id=$curApp" ; then
        
        if [[ ! -f "$SSBAppPath/Contents/MacOS/Epichrome" ]] ; then
            
            # LAUNCHER IS NOT IN PLACE, SO TRY TO REPAIR
            
            # variables for setenginestate
            myPayloadEnginePath="$SSBPayloadPath/$epiPayloadEngineDir"
            myPayloadLauncherPath="$SSBPayloadPath/$epiPayloadLauncherDir"
            
            # perform restore & record result
            if scan_restore ; then
                appRestoreSuccessList+=( "$curApp" )
                curDetail="  ✅ Restored app \"${SSBAppPath##*/}\"."
            else
                appRestoreErrorList+=( "$curApp" )
                curDetail="  🚫 Failed to restore app \"${SSBAppPath##*/}\". ($errmsg)"
            fi
        else
            debuglog "  App $curApp appears to be intact."
            continue
        fi
    else
        debuglog "  App $curApp is currently running."
        continue
    fi
done

# build final status message
if [[ "${#appRestoreSuccessList[@]}" -gt 0 ]] ; then
    finalStatus+=" Restored: ${#appRestoreSuccessList[@]}"
    # [[ "${#appRestoreSuccessList[@]}" -gt 1 ]] && finalStatus+='s' $$$$
fi
if [[ "${#appRestoreErrorList[@]}" -gt 0 ]] ; then
    [[ "$finalStatus" ]] && finalStatus+=','
    finalStatus+=" Failed: ${#appRestoreErrorList[@]}"
    # [[ "${#appRestoreErrorList[@]}" -gt 1 ]] && finalStatus+='s'  $$$
fi

if [[ "$finalStatus" ]] ; then
    finalStatus+='. See Details or log for info.'
else
    finalStatus=' No apps found to restore.'
fi

echo "Scan complete.$finalStatus"

cleanexit
