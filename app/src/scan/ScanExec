#!/bin/bash
#
#  ScanExec: Main executable for Epichrome Scan.app
#
#  Copyright (C) 2020  David Marmor
#
#  https://github.com/dmarmor/epichrome
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#


# SCAN OR LOGIN APP SETUP

scanMode='EPISCANMODE'

if [[ "$scanMode" = 'login' ]] ; then
    myLogID='EpichromeLogin'
    myLogFilePrefix='epichrome_login_log'
fi


# CORE APP VARIABLES

myAppPath="${BASH_SOURCE[0]%/Contents/Resources/script}"
myScriptPath="$myAppPath/Contents/Resources/Scripts"

logNoStderr=1


# LOAD CORE SCRIPT

source "$myScriptPath/core.sh" 'coreDoInit=1' 'coreContext=scan' || exit 1
[[ "$ok" ]] || abort


# DON'T TRAP SIGINT

trap '' INT


# --- FUNCTION DEFINITIONS ---

# CLEANUP -- clean up from an interrupted scan
function cleanup {
    
    # we were interrupted in the middle of a restore
    if [[ "$restoreLock" && ( ! -f "$SSBAppPath/Contents/MacOS/Epichrome" ) ]] ; then
        errlog "Interrupted while restoring app $curApp. Attempting to complete restore."
        scan_restore
    fi
    
    # $$$$ if nothing happened, quit parent app
    if false ; then
        kill "$PPID"
    fi
}


# SCAN_RESTORE: attempt to restore an app
restoreLock=
function scan_restore {
    
    # turn on restore lock
    restoreLock=1
    
    if [[ -d "$myPayloadLauncherPath" ]] ; then
        
        
        if issamedevice "$myPayloadLauncherPath" "$SSBAppPath" ; then
            
            # launcher is in payload, so try the canonical method
            setenginestate OFF "$curApp"
            
            if [[ "$ok" ]] ; then
                restoreLock=
            else
                
                # setenginestate failed, so try restoring launcher by hand
                ok=1 ; errmsg=
                
                try /bin/rm -rf "$SSBAppPath/Contents" \
                        "Unable to remove engine contents for app $curApp."
                if [[ "$ok" ]] ; then
                    try /bin/mv "$myPayloadLauncherPath" "$SSBAppPath/Contents" \
                            "Unable to restore launcher for app $curApp."
                fi
                
                if [[ "$ok" ]] ; then
                    restoreLock=
                    deletepayload '' "$curApp"
                else
                    # try another method
                    ok=1 ; errmsg=
                fi
            fi
        else
            
            # payload is on wrong device
            errlog "Payload for app $curApp is on a different device from app."
        fi
    fi
    
    if [[ "$restoreLock" ]] ; then
        
        # fallback: try to restore from failsafe backup
        debuglog "Attempting to restore app $curApp from failsafe backup."
        
        myFailsafeFile="$curApp/$appDataBackupDir/$appDataFailsafeFile"
        
        if [[ -f "$myFailsafeFile" ]] ; then
            try /bin/rm -rf "$SSBAppPath/Contents" \
                    "Unable to remove engine contents from app $curApp."
            try /usr/bin/tar xzf "$myFailsafeFile" --cd "$SSBAppPath" \
                    "Unable to restore app $curApp from failsafe backup."
            restoreLock=
            if [[ "$ok" ]] ; then
                : # $$$ MARK FOR NOTIFICATION
            else
                ok=1 ; errmsg=
                # $$$$ MARK FOR NOTIFICATION?
            fi
            deletepayload '' "$curApp"
        else
            restoreLock=
            errlog "Cannot restore app $curApp: no launcher payload and no failsafe backup found."
            # $$$ MARK FOR NOTIFICATION?
        fi
    fi
    
    # if we got here, turn off lock just in case
    restoreLock=
}


# PROGRESSMSG -- print a message for the progress bar
#  progressmsg(aAction aCurItem aNumItems aStatus)
function progressmsg {
    
    # arguments
    local aAction="$1" ; shift
    local aCurItem="$1" ; shift
    local aNumItems="$1" ; shift
    local aStatus="$1" ; shift ; [[ "$aStatus" ]] && aStatus=" - $aStatus"
    
    # percentage (or count)
    local aPercent=
    if [[ "$aCurItem" && "$aNumItems" ]] ; then
        aPercent=" ($(($aCurItem * 100 / $aNumItems))%)"
    elif [[ "$aCurItem" || "$aNumItems" ]] ; then
        aPercent=" (${aCurItem}${aNumItems})"
    fi
    
    echo "$aAction$aPercent$aStatus"
}


# --- MAIN BODY ---

# initialize log file
initlogfile


# LOAD LAUNCH FUNCTIONS

safesource "$myScriptPath/launch.sh"
[[ "$ok" ]] || abort


# SCAN FOR ZOMBIE ENGINES

# navigate to Epichrome app data directory
try cd "$appDataPathBase" 'Unable to navigate to app data directory.'

# get list of everything in the directory
appDataDirItemList=( * )
appIDList=()

# progress bar data
numItems="${#appDataDirItemList[@]}"
curItemNum=-1

for curApp in "${appDataDirItemList[@]}" ; do
    
    # reset ok status
    ok=1 ; errmsg=
    
    # clear config variables
    SSBPayloadPath=
    SSBAppPath=
    
    # update progress bar
    curItemNum=$(($curItemNum + 1))
    progressmsg 'Scanning apps' $curItemNum $numItems
    
    # check if it's really an app directory
    [[ -d "$curApp" ]] || continue
    
    # add to (currently useless) list of IDs
    appIDList+=( "$curApp" )
    
    # check app's config file
    curConfig="$curApp/config.sh"
    if [[ ! -f "$curConfig" ]] ; then
        debuglog "Skipping app $curApp: no config file."
        continue
    fi
    
    # load config
    safesource "$curApp/config.sh" "config for app $curApp"
    [[ "$ok" ]] || continue
    
    # check payload directory
    if [[ ! "$SSBPayloadPath" ]] ; then
        debuglog "Skipping app $curApp: no payload path in config."
        continue
    fi
    
    # we have a current app to check
    debuglog "Checking app ID $curApp..."
    
    # find app
    if [[ ! "$SSBAppPath" || (! -d "$SSBAppPath" ) ]] ; then
        debuglog "  Current path for app $curApp not found in config. Finding by ID."
        
        try 'SSBAppPath=(n)' /usr/bin/osascript "$myScriptPath/launch.scpt" \
"{
   \"action\": \"find\",
   \"id\": \"$appIDBase.$curApp\"
}" \
                "Error finding app $curApp by ID."
        [[ "$ok" ]] || continue
            
        # make sure we found exactly one path
        if [[ "${#SSBAppPath[@]}" -lt 1 ]] ; then
            
            # no path found
            debuglog "  App $curApp not found."
            
            # remove orphan payload if it exists
            deletepayload '' "$curApp"
            continue
            
        elif [[ "${#SSBAppPath[@]}" -gt 1 ]] ; then
            
            # multiple apps found for this ID
            errlog "Cannot process app $curApp. ${#SSBAppPath[@]} different copies found:"
            for p in "${SSBAppPath[@]}" ; do errlog "  $p" ; done
            continue
        fi
        
        # set app path
        SSBAppPath="${SSBAppPath[0]}"
    fi
        
    # make sure this app is not running
    if ! /usr/bin/pgrep -fiq -- "--epichrome-id=$curApp" ; then
        
        if [[ ! -f "$SSBAppPath/Contents/MacOS/Epichrome" ]] ; then
            
            # LAUNCHER IS NOT IN PLACE, SO TRY TO REPAIR
            
            # variables for setenginestate
            myPayloadEnginePath="$SSBPayloadPath/$epiPayloadEngineDir"
            myPayloadLauncherPath="$SSBPayloadPath/$epiPayloadLauncherDir"
            
            scan_restore
        else
            debuglog "  App $curApp appears to be intact."
            continue
        fi
    else
        debuglog "  App $curApp is currently running."
        continue
    fi
done

progressmsg 'Scan complete.'

cleanexit
